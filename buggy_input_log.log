commit 390e5b04b7e7f9b8ddb7d9848defef9130a478a1
Author: FJJLeon <695048014@qq.com>
Date:   Thu Jun 13 00:30:07 2019 +0800

    lab6: buggy recv pkt, input env

diff --git a/kern/e1000.c b/kern/e1000.c
index ebd8d46..2a821d9 100644
--- a/kern/e1000.c
+++ b/kern/e1000.c
@@ -8,8 +8,8 @@ static struct E1000 *base;
 //struct tx_desc *tx_descs;
 #define N_TXDESC (PGSIZE / sizeof(struct tx_desc))
 //#define N_TXDESC 64
-struct tx_desc tx_descs[N_TXDESC] __attribute__((aligned(16)));
-char tx_buf[N_TXDESC][MAX_PKTSIZE];
+struct tx_desc tx_descs[N_TXDESC] __attribute__((aligned(PGSIZE)));
+char tx_buf[N_TXDESC][MAX_PKTSIZE] __attribute__ ((aligned (PGSIZE)));
 
 int
 e1000_tx_init()
@@ -22,6 +22,7 @@ e1000_tx_init()
 	for (int i=0; i<N_TXDESC; i++) {
 		tx_descs[i].addr = PADDR(tx_buf[i]);
 		tx_descs[i].status |= E1000_TX_STATUS_DD;
+		tx_descs[i].cmd = E1000_TX_CMD_RS | E1000_TX_CMD_EOP;
 	}
 	// Set hardward registers
 	// Look kern/e1000.h to find useful definations
@@ -30,14 +31,16 @@ e1000_tx_init()
 	base->TDBAH = 0;
 	// set TD Length register
 	base->TDLEN = sizeof(tx_descs);
+	assert(sizeof(tx_descs) == sizeof(struct tx_desc) * N_TXDESC);
 	// set TD head and tail register
 	base->TDH = 0;
 	base->TDT = 0;
 	// set Transmit Control register
-	base->TCTL |= E1000_TCTL_EN;
-	base->TCTL |= E1000_TCTL_PSP;
-	base->TCTL |= E1000_TCTL_CT_ETHER;
-	base->TCTL |= E1000_TCTL_COLD_FULL_DUPLEX;
+	base->TCTL = (E1000_TCTL_EN | E1000_TCTL_PSP | 
+			E1000_TCTL_CT_ETHER | E1000_TCTL_COLD_FULL_DUPLEX);
+	//base->TCTL |= E1000_TCTL_PSP;
+	//base->TCTL |= E1000_TCTL_CT_ETHER;
+	//base->TCTL |= E1000_TCTL_COLD_FULL_DUPLEX;
 	// set Transmit Inter Packet Gap register
 	base->TIPG = E1000_TIPG_DEFAULT;
 
@@ -46,8 +49,8 @@ e1000_tx_init()
 
 //struct rx_desc *rx_descs;
 #define N_RXDESC (PGSIZE / sizeof(struct rx_desc))
-struct rx_desc rx_descs[N_RXDESC];
-char rx_buf[N_RXDESC][MAX_PKTSIZE];
+struct rx_desc rx_descs[N_RXDESC] __attribute__((aligned(PGSIZE)));
+char rx_buf[N_RXDESC][MAX_PKTSIZE] __attribute__((aligned(PGSIZE)));
 
 int
 e1000_rx_init()
@@ -60,20 +63,24 @@ e1000_rx_init()
 	memset(rx_buf, 0, sizeof(rx_buf));
 	for (int i=0; i<N_RXDESC; i++) {
 		rx_descs[i].addr = PADDR(rx_buf[i]);
+		rx_descs[i].status = E1000_RX_STATUS_DD;
 	}
 	// Set hardward registers
 	// Look kern/e1000.h to find useful definations
 	// set card MAC address
 	base->RAL = QEMU_MAC_LOW;
 	base->RAH = QEMU_MAC_HIGH;
+	for (int i=0; i<128; i++) {
+		base->MTA[i] = 0;
+	}
 	// set TD Base Address register
 	base->RDBAL = PADDR(rx_descs);
 	base->RDBAH = 0;
 	// set TD length register
 	base->RDLEN = sizeof(rx_descs);
 	// set TD head and tail register
-	base->RDH = 1;
-	base->RDT = 0;
+	base->RDH = 0;
+	base->RDT = N_RXDESC-1;
 	// set Receive Control register
 	base->RCTL |= E1000_RCTL_EN;
 	base->RCTL |= E1000_RCTL_BSIZE_2048;
@@ -116,7 +123,7 @@ e1000_tx(const void *buf, uint32_t len)
 	cprintf("tx tdt:%d, tdh:%d\n", tdt, base->TDH);
 	// check the next descriptor is free
 	if(!(tx_descs[tdt].status & E1000_TX_STATUS_DD))
-		//return -E_AGAIN;// seems queue full and should retry
+		return -E_AGAIN;// seems queue full and should retry
 
 	// set up next descriptor
 	memset(tx_buf[tdt], 0 , sizeof(tx_buf[tdt]));
@@ -141,6 +148,17 @@ e1000_rx(void *buf, uint32_t len)
 	// the packet
 	// Do not forget to reset the decscriptor and
 	// give it back to hardware by modifying RDT
-
-	return 0;
+	uint32_t tail = (base->RDT + 1) % N_RXDESC;
+    //cprintf("tail value :%d\n", tail) ;
+        
+
+    if ((rx_descs[tail].status & E1000_RX_STATUS_DD) != E1000_RX_STATUS_DD) 
+        return -E_AGAIN;
+    if (rx_descs[tail].length < len)
+        len = rx_descs[tail].length;
+
+    memcpy(buf, rx_buf[tail], len);
+    rx_descs[tail].status &= !E1000_RX_STATUS_DD;
+    base->RDT = tail;
+    return rx_descs[tail].length;
 }
diff --git a/kern/syscall.c b/kern/syscall.c
index ec63988..87cebf8 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -478,7 +478,8 @@ sys_net_recv(void *buf, uint32_t len)
 	// Check the user permission to [buf, buf + len]
 	// Call e1000_rx to fill the buffer
 	// Hint: e1000_rx only accept kernel virtual address
-	return -1;
+	user_mem_assert(curenv, buf, len, PTE_U);
+	return e1000_rx(buf, len);
 }
 
 // Dispatches to the correct kernel function, passing the arguments.
@@ -531,6 +532,8 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 			return sys_time_msec();
 		case SYS_net_send:
 			return sys_net_send((const void *)a1, (uint32_t)a2);
+		case SYS_net_recv:
+			return sys_net_recv((void *)a1, (uint32_t)a2);
 		default:
 			return -E_INVAL;
 	}
diff --git a/net/input.c b/net/input.c
index e95b621..e610207 100644
--- a/net/input.c
+++ b/net/input.c
@@ -14,4 +14,30 @@ input(envid_t ns_envid)
 	// Hint: When you IPC a page to the network server, it will be
 	// reading from it for a while, so don't immediately receive
 	// another packet in to the same physical page.
+	int i, r;
+    r = sys_page_alloc(0, (void *)REQVA, PTE_U|PTE_W|PTE_P);
+	if (r < 0)
+		panic("ns_input: could not alloc page of memory");
+	r = sys_page_alloc(0, (void *)(REQVA+PGSIZE), PTE_U|PTE_W|PTE_P);
+	union Nsipc *nsipc_page_1 = (union Nsipc *)REQVA;
+	union Nsipc *nsipc_page_2 = (union Nsipc *)(REQVA+PGSIZE);
+	bool page1 = true;
+	while (true)
+	{
+		union Nsipc *nsipc_page;
+		if (page1)
+			nsipc_page = nsipc_page_1;
+		else
+			nsipc_page = nsipc_page_2;
+		page1 = !page1;
+
+		r = sys_net_recv(&nsipc_page->pkt.jp_data, 2048);
+		if (r == -E_AGAIN){
+			sys_yield();
+			continue;
+		}
+		else if (r<0)
+			panic("error in sys_recv_packet, %e", r);
+		ipc_send(ns_envid, NSREQ_INPUT, nsipc_page, PTE_P|PTE_W|PTE_U);
+	}
 }
diff --git a/net/output.c b/net/output.c
index 5d18d6c..410529c 100644
--- a/net/output.c
+++ b/net/output.c
@@ -25,7 +25,7 @@ output(envid_t ns_envid)
 			if (r != -E_AGAIN)
 				panic("output env: send fail but not full\n");
 			cprintf("output env: net send queue full\n");
-			sys_yield();
+			//sys_yield();
 		}
 	}
 }
diff --git a/net/testinput.c b/net/testinput.c
index 22cf937..a71e99f 100644
--- a/net/testinput.c
+++ b/net/testinput.c
@@ -104,7 +104,7 @@ umain(int argc, char **argv)
 			panic("Unexpected IPC %d", req);
 
 		hexdump("input: ", pkt->jp_data, pkt->jp_len);
-		cprintf("\n");
+		cprintf("1 ");
 
 		// Only indicate that we're waiting for packets once
 		// we've received the ARP reply
